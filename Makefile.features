# Process FEATURES variables
#
# The board/board common are responsible for defining the CPU and CPU_MODEL
# variables in their Makefile.features.
# This makes them available when setting features based on CPU_MODEL in the cpu
# Makefile.features and also during dependency resolution.

# Transition:
#   Moving 'CPU/CPU_MODEL' to Makefile.features is an ongoing work and may not
#   reflect the state of all boards for the moment.

include $(BOARDSDIR)/$(BOARD)/Makefile.features

# Sanity check
ifeq (,$(CPU))
  $(error CPU must be defined by board / board_common Makefile.features)
endif

include $(RIOTCPU)/$(CPU)/Makefile.features


# Resolve FEATURES_ variables
# Their value will only be complete after resolving dependencies

# Features that are only optional and not required at the same time.
# The policy is to by default use by features if they are provided by the BSP.
FEATURES_OPTIONAL_ONLY = $(sort $(filter-out $(FEATURES_REQUIRED),$(FEATURES_OPTIONAL)))
FEATURES_OPTIONAL_USED = $(sort $(filter $(FEATURES_PROVIDED),$(FEATURES_OPTIONAL_ONLY)))
# Optional features that will not be used because they are not provided
FEATURES_OPTIONAL_MISSING = $(sort $(filter-out $(FEATURES_PROVIDED),$(FEATURES_OPTIONAL_ONLY)))

# Features that are used without taking "one out of" dependencies into account
FEATURES_USED_SO_FAR = $(sort $(FEATURES_REQUIRED) $(FEATURES_OPTIONAL_USED))

# Features that are provided and not blacklisted
FEATURES_USABLE = $(filter-out $(FEATURES_BLACKLIST),$(FEATURES_PROVIDED))

# Additionally required features due to the "one out of" dependencies
# Algorithm explained:
# - For each feature list "item" in FEATURES_REQUIRED_ANY:
#     - Filter the list of already used features by any of the features in "item"
#     - Filter the list of usable features by any of the features in "item"
#     - Combine (without reordering) those two lists, and append "item" (with pipes)
#     - Take the first work out of this combined list
# ==> All already used features matching one of the feature in item will be in front of the list (if any)
# ==> All usable features matching one of the features in item will come next
# ==> The whole list as item with pipes (e.g. "periph_spi|periph_i2c") will be the last item
#     ==> This will only pull in new features if strictly required
FEATURES_REQUIRED_ONE_OUT_OF = $(foreach item,$(FEATURES_REQUIRED_ANY),$(word 1,$(filter $(subst |, ,$(item)),$(FEATURES_USED_SO_FAR) $(FEATURES_USABLE)) $(item)))

# Features that are required by the application but not provided by the BSP
# Having features missing may case the build to fail.
FEATURES_MISSING = $(sort $(filter-out $(FEATURES_PROVIDED),$(FEATURES_REQUIRED) $(FEATURES_REQUIRED_ONE_OUT_OF)))

# Features that are used for an application
FEATURES_USED = $(sort $(FEATURES_REQUIRED) $(FEATURES_REQUIRED_ONE_OUT_OF) $(FEATURES_OPTIONAL_USED))

# Used features that conflict when used together
FEATURES_CONFLICTING = $(sort $(foreach conflict,$(FEATURES_CONFLICT),$(call _features_conflicting,$(conflict))))

# Return conflicting features from the conflict string feature1:feature2
#   $1: feature1:feature2
#   Return the list of conflicting features
_features_conflicting = $(if $(call _features_used_conflicting,$(subst :, ,$1)),$(subst :, ,$1))
# Check if all features from the list are used
#   $1: list of features that conflict together
#   Return non empty on error
_features_used_conflicting = $(filter $(words $1),$(words $(filter $(FEATURES_USED),$1)))

# Features that are used by the application but blacklisted by the BSP.
# Having blacklisted features may cause the build to fail.
FEATURES_USED_BLACKLISTED = $(sort $(filter $(FEATURES_USED), $(FEATURES_BLACKLIST)))
