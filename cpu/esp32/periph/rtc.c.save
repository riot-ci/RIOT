/*
 * Copyright (C) 2018 Gunar Schorcht
 *
 * This file is subject to the terms and conditions of the GNU Lesser
 * General Public License v2.1. See the file LICENSE in the top level
 * directory for more details.
 */

/**
 * @ingroup     cpu_esp32
 * @ingroup     drivers_periph_rtc
 * @{
 *
 * @file
 * @brief       Low-level RTC driver implementation
 *
 * @author      Gunar Schorcht <gunar@schorcht.net>
 *
 * @}
 */

/* 
 * If USE_SYSTEM_TIMER is 1, microsecond system timer is used to emulate an
 * RTC, otherwise the RTC timer is used. Advantage of using RTC over sytem
 * timer is that it also continues in deep sleep and after software reset.
 */
#define USE_SYSTEM_TIMER 1

#define ENABLE_DEBUG (0)
#include "debug.h"
#include "common.h"

#include <string.h>

#include "cpu.h"
#include "esp_attr.h"
#include "log.h"
#include "irq_arch.h"
#include "periph/rtc.h"
#include "rom/ets_sys.h"
#include "soc/dport_reg.h"
#include "soc/rtc_cntl_struct.h"
#include "soc/timer_group_struct.h"
#include "syscalls.h"
#include "xtensa/xtensa_api.h"

/* TODO move to TIMER_SYSTEM definition in periph_cpu.h */
#define TIMER_SYSTEM_GROUP      TIMERG0
#define TIMER_SYSTEM_INT_MASK   BIT(0)
#define TIMER_SYSTEM_INT_SRC    ETS_TG0_T0_LEVEL_INTR_SOURCE
#define TIMER_SYSTEM_CLK_HZ     (1000000UL)

/* we can't include soc/rtc.h because of rtc_init declaration conflicts */
extern uint32_t rtc_clk_slow_freq_get_hz(void);

#if USE_SYSTEM_TIMER

#define RTC_TIMER_CLK_HZ    TIMER_SYSTEM_CLK_HZ

#else /* USE_SYSTEM_TIMER */

#define RTC_TIMER_CLK_HZ    rtc_clk_slow_freq_get_hz()

#endif /* USE_SYSTEM_TIMER */

/* static variables */
static rtc_alarm_cb_t RTC_RODATA_ATTR _rtc_alarm_cb = NULL;
static void*          RTC_RODATA_ATTR _rtc_alarm_arg = NULL;
static time_t         RTC_RODATA_ATTR _sys_alarm_time = 0;

/* save several time stamps */
static uint64_t RTC_RODATA_ATTR _rtc_time_init = 0;
static uint64_t RTC_RODATA_ATTR _rtc_time_set = 0;
static time_t   RTC_RODATA_ATTR _sys_time_set = 0;

/* forward declarations */
static uint64_t _rtc_time_raw(void);
static void IRAM_ATTR _rtc_timer_handler(void* arg);

time_t _rtc_time_sec(void)
{
    uint64_t _rtc_time;
    _rtc_time  = _rtc_time_raw();
    _rtc_time /= RTC_TIMER_CLK_HZ;
    return _rtc_time;
}

void rtc_init(void)
{
    _rtc_time_init = _rtc_time_raw();
}

void rtc_poweron(void)
{
    /* RTC is always on, also in deep sleep mode */
    return;
}

void rtc_poweroff(void)
{
    /* RTC is always on, also in deep sleep mode */
    return;
}

int rtc_set_time(struct tm *ttime)
{
    _sys_time_set = mktime (ttime);
    _rtc_time_set = _rtc_time();

    DEBUG("%s sys_time=%ld rtc_timer=%lld\n", __func__, _sys_time_set, _rtc_time_set);

    return 0;
}

static time_t _sys_time (_rtc_time)
{
    return _sys_time_set + (_rtc_time_raw() - _rtc_time_set) / RTC_TIMER_CLK_HZ;
}

int rtc_get_time(struct tm *ttime)
{

    DEBUG("%s sys_time=%ld rtc_time=%lld\n", __func__, _sys_time, _rtc_time);

    struct tm* _time = localtime(&_sys_time);
    if (_time) {
        memcpy(ttime, _time, sizeof(struct tm));
        return 0;
    }
    else {
        return -1;
    }
}

int rtc_get_alarm(struct tm *time)
{
    struct tm* _time = localtime(&_sys_alarm_time);
    if (_time) {
        memcpy(time, _time, sizeof(struct tm));
        return 0;
    }
    else {
        return -1;
    }
}

int rtc_set_alarm(struct tm *time, rtc_alarm_cb_t cb, void *arg)
{
    _rtc_alarm_cb = cb;
    _rtc_alarm_arg = arg;

    /* determine the current system time in seconds */
    uint64_t _rtc_time = _rtc_time(); /* current rtc time in sec*/
    time_t   _sys_time = _sys_time_set + (_rtc_time - _rtc_time_set) / RTC_TIMER_CLK_HZ;

    /* determine the offset of alarm time to current time in seconds */
    _sys_alarm_time = mktime(time);
    time_t _sys_offset = _sys_alarm_time - _sys_time;

    DEBUG("%s rtc=%ld time=%ld offset=%ld\n", 
          __func__, _rtc_time, _sys_time, _sys_offset);

    /* 
     * RTC doesn't provide alarm functionality in active mode. At least
     * the RTC main timer seems not to work. Therefore we always use the
     * system timer for alarms. The Advantage of using RTC over sytem timer
     * is that it also continues in deep sleep and after software reset.
     */
    #if 1 /* TODO should be USE_SYSTEM_TIMER */

    /* determine the offset of alarm time to current time in RTC time */
    uint64_t _rtc_alarm_time = 0;
    _rtc_alarm_time  = system_get_time_64();
    _rtc_alarm_time += _sys_offset * TIMER_SYSTEM_CLK_HZ;

    /* set the timer value */
    TIMER_SYSTEM.alarm_high = (uint32_t)(_rtc_alarm_time >> 32);
    TIMER_SYSTEM.alarm_low  = (uint32_t)(_rtc_alarm_time & 0xffffffff);

    /* clear the bit in status and set the bit in interrupt enable */
    TIMER_SYSTEM_GROUP.int_clr_timers.val |= TIMER_SYSTEM_INT_MASK;
    TIMER_SYSTEM_GROUP.int_ena.val |= TIMER_SYSTEM_INT_MASK;

    /* route all timer interrupt sources to the same level type interrupt */
    intr_matrix_set(PRO_CPU_NUM, TIMER_SYSTEM_INT_SRC, CPU_INUM_RTC);

    /* set interrupt handler and enable the CPU interrupt */
    xt_set_interrupt_handler(CPU_INUM_RTC, _rtc_timer_handler, NULL);
    xt_ints_on(BIT(CPU_INUM_RTC));

    /* enable the timer alarm */
    TIMER_SYSTEM.config.level_int_en = 1;
    TIMER_SYSTEM.config.alarm_en = 1;

    #else

    /* determine the offset of alarm time to current time in RTC time */
    uint64_t _rtc_alarm_time;
    _rtc_alarm_time  = _rtc_time_raw(); /* current rtc time */
    _rtc_alarm_time += _sys_offset * RTC_TIMER_CLK_HZ;

    /* set the timer value */
    RTCCNTL.slp_timer0 = _rtc_alarm_time & 0xffffffff;
    RTCCNTL.slp_timer1.slp_val_hi = _rtc_alarm_time >> 32;

    DEBUG("%s %08lx%08lx \n", __func__, RTCCNTL.slp_timer1.slp_val_hi, RTCCNTL.slp_timer0);

    /* enable RTC timer alarm */
    RTCCNTL.slp_timer1.main_timer_alarm_en = 1;

    /* clear and enable RTC timer interrupt */
    RTCCNTL.int_clr.rtc_main_timer = 1;
    RTCCNTL.int_ena.rtc_main_timer = 1;

    /* route all RTC interrupt sources to the same level type interrupt */
    intr_matrix_set(PRO_CPU_NUM, DPORT_PRO_RTC_CORE_INTR_MAP_REG, CPU_INUM_RTC);

    /* set interrupt handler and enable the CPU interrupt */
    xt_set_interrupt_handler(CPU_INUM_RTC, _rtc_timer_handler, NULL);
    xt_ints_on(BIT(CPU_INUM_RTC));

    #endif

    return 0;
}

void rtc_clear_alarm(void)
{
    _rtc_alarm_cb = NULL;
    _rtc_alarm_arg = NULL;

    #if 1 /* TODO should be USE_SYSTEM_TIMER, see rtc_set_alarm */

    /* reset the bit in interrupt enable */
    TIMER_SYSTEM_GROUP.int_ena.val |= TIMER_SYSTEM_INT_MASK;

    /* disable the CPU interrupt */
    xt_ints_on(BIT(CPU_INUM_RTC));

    /* disable the timer alarm */
    TIMER_SYSTEM.config.level_int_en = 0;
    TIMER_SYSTEM.config.alarm_en = 0;

    #else
    /* disable RTC timer alarm and disable the RTC timer interrupt */
    RTCCNTL.slp_timer1.main_timer_alarm_en = 0;
    RTCCNTL.int_ena.rtc_main_timer = 0;

    /* route all RTC interrupt sources to the same level type interrupt */
    intr_matrix_set(PRO_CPU_NUM, DPORT_PRO_RTC_CORE_INTR_MAP_REG, CPU_INUM_RTC);

    /* disable the the CPU interrupt */
    xt_ints_on(BIT(CPU_INUM_RTC));
    #endif
}

static uint64_t _rtc_time_raw(void)
{
    #if USE_SYSTEM_TIMER

    return system_get_time_64();

    #else

    /* trigger timer register update */
    RTCCNTL.time_update.update = 1;
    /* wait until values in registers are valid */    
    while (!RTCCNTL.time_update.valid) { }
    /* read the time and return */        
    uint64_t rtc_time;
    rtc_time  = RTCCNTL.time0;
    rtc_time += ((uint64_t)RTCCNTL.time1.val) << 32;
    return rtc_time;

    #endif
}

static void IRAM_ATTR _rtc_timer_handler(void* arg)
{
    irq_isr_enter();

    #if 1 /* TODO should be USE_SYSTEM_TIMER */

    /* check for RTC timer interrupt */
    if (TIMER_SYSTEM_GROUP.int_st_timers.val & TIMER_SYSTEM_INT_MASK) {

        DEBUG("%s\n", __func__);

        /* disable alarms */
        TIMER_SYSTEM.config.level_int_en = 0;
        TIMER_SYSTEM.config.alarm_en = 0;

        /* clear the bit in interrupt enable and status register */
        TIMER_SYSTEM_GROUP.int_ena.val &= ~TIMER_SYSTEM_INT_MASK;
        TIMER_SYSTEM_GROUP.int_clr_timers.val |= TIMER_SYSTEM_INT_MASK;

        /* call back registered function */
        if (_rtc_alarm_cb) {
            _rtc_alarm_cb(_rtc_alarm_arg);
        }
    }

    #else

    /* check for RTC timer interrupt */
    if (RTCCNTL.int_st.rtc_main_timer) {
        /* clear the interrupt */
        RTCCNTL.int_clr.rtc_main_timer = 1;
        /* call back registered function */
        if (_rtc_alarm_cb) {
            _rtc_alarm_cb(_rtc_alarm_arg);
        }
    }
    /* clear all interrupts */
    RTCCNTL.int_clr.val = 0x1ff;

    #endif

    irq_isr_exit();
}
