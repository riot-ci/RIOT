# Define the CPU family so we can differentiate between them in the code
CFLAGS += -DCPU_FAM_$(call uppercase_and_underscore,$(CPU_FAM))

# Generate ASF compatible model definition
CFLAGS += -D__$(call uppercase_and_underscore,$(CPU_MODEL))__

# Compute CPU_LINE
LINE   := $(shell echo $(CPU_MODEL) | sed -E -e 's/^sam([a-z][0-9][0-9])(.)([0-9][0-9])(.)/\1 \2 \3 \4/')
FAMILY := $(word 1, $(LINE))
TYPE1  := $(word 2, $(LINE))
MEMORY := $(word 3, $(LINE))
TYPE2  := $(word 4, $(LINE))

# ROM length is directly encoded in the part number
ROM_LEN := $(shell echo $$((1 << $(MEMORY))))

# On SAMD21, SAML21 RAM is always ⅛ of ROM
ifneq (,$(filter samd21 saml21,$(CPU)))
  RAM_LEN := $(shell echo $$(($(ROM_LEN)/8)))
endif
# On SAML1x RAM is ¼ of ROM, except on SAML11x14 where it is ½
ifneq (,$(filter saml1x,$(CPU)))
ifneq ($(and $(filter l11, $(FAMILY)), $(filter 14, $(MEMORY))),)
  RAM_LEN := 8K
else
  RAM_LEN := $(shell echo $$(($(ROM_LEN)/4)))
endif
endif
# On SAMD5x RAM is always at least 128k, incrementing by 64 with every ROM increment
ifneq (,$(filter samd5x,$(CPU)))
  RAM_LEN := $(shell echo $$(( (64 * ($(MEMORY) - 18) + 128) * 1024 )))
endif

ROM_START_ADDR ?= 0x00000000
RAM_START_ADDR ?= 0x20000000

# this CPU implementation doesn't use CMSIS initialization
CFLAGS += -DDONT_USE_CMSIS_INIT
CFLAGS += -DDONT_USE_PREDEFINED_CORE_HANDLERS
CFLAGS += -DDONT_USE_PREDEFINED_PERIPHERALS_HANDLERS

# For Cortex-M cpu we use the common cortexm.ld linker script
LINKER_SCRIPT ?= cortexm.ld

INCLUDES += -I$(RIOTCPU)/sam0_common/include
