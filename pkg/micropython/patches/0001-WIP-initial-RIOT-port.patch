From 2b877e2d3314662252f1859f418364fded4c4d55 Mon Sep 17 00:00:00 2001
From: Kaspar Schleiser <kaspar@schleiser.de>
Date: Sun, 10 May 2015 20:01:16 +0200
Subject: [PATCH] WIP: initial RIOT port

---
 riot/Makefile       | 54 ++++++++++++++++++++++++++++++
 riot/README.md      | 15 +++++++++
 riot/help.c         | 93 +++++++++++++++++++++++++++++++++++++++++++++++++++
 riot/mp_riot.c      | 75 ++++++++++++++++++++++++++++++++++++++++++
 riot/mpconfigport.h | 95 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 riot/qstrdefsport.h |  3 ++
 riot/riot_io.c      | 46 ++++++++++++++++++++++++++
 7 files changed, 381 insertions(+)
 create mode 100644 riot/Makefile
 create mode 100644 riot/README.md
 create mode 100644 riot/help.c
 create mode 100644 riot/mp_riot.c
 create mode 100644 riot/mpconfigport.h
 create mode 100644 riot/qstrdefsport.h
 create mode 100644 riot/riot_io.c

diff --git a/riot/Makefile b/riot/Makefile
new file mode 100644
index 0000000..6cafb7b
--- /dev/null
+++ b/riot/Makefile
@@ -0,0 +1,54 @@
+#
+# set up some of mkenv.py's settings
+all:
+.PHONY: all
+
+BUILD ?= $(BINDIRBASE)/pkg/$(BOARD)/micropython
+
+TOP = $(CURDIR)/..
+PY_SRC = $(TOP)/py
+
+RM ?= rm
+CP ?= cp
+SED ?= sed
+ECHO ?= @echo
+MKDIR ?= mkdir
+PYTHON ?= python
+
+ifeq ($(QUIET),1)
+Q = @
+else
+Q =
+endif
+
+MKENV_INCLUDED = 1
+
+# qstr definitions (must come before including py.mk)
+QSTR_DEFS = qstrdefsport.h
+
+# include py core make definitions
+include ../py/py.mk
+
+INC =  -I.
+INC += -I..
+INC += -I../lib/mp-readline
+INC += -I../stmhal
+INC += -I$(BUILD)
+INC += $(INCLUDES)
+
+Wno = -Wno-vla -Wno-unused-parameter -Wno-pedantic
+
+CFLAGS += -DNDEBUG $(INC) $(Wno)
+
+SRC_C = $(wildcard *.c) \
+	stmhal/pyexec.c \
+	lib/mp-readline/readline.c
+
+OBJ = $(PY_O) $(addprefix $(BUILD)/, $(SRC_C:.c=.o) $(SRC_S:.s=.o))
+
+all: $(BINDIR)micropython.a
+
+$(BINDIR)micropython.a: $(OBJ)
+	$(AD)$(AR) $(ARFLAGS) $@ $?
+
+include ../py/mkrules.mk
diff --git a/riot/README.md b/riot/README.md
new file mode 100644
index 0000000..90ce660
--- /dev/null
+++ b/riot/README.md
@@ -0,0 +1,15 @@
+# (draft)
+
+Micropython has been PR'ed for RIOT as 
+
+# Support for running micropython on RIOT
+
+## What is RIOT?
+
+RIOT (http://riot-os.org) is RTOS for resource constrained IoT devices.
+
+See http://riot-os.org or https://github.com/RIOT-OS/RIOT for more information
+
+## Status
+
+Currently the port is very minimal. Micro Python has been integrated
diff --git a/riot/help.c b/riot/help.c
new file mode 100644
index 0000000..a398779
--- /dev/null
+++ b/riot/help.c
@@ -0,0 +1,93 @@
+/*
+ * This file is part of the Micro Python project, http://micropython.org/
+ *
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2013, 2014 Damien P. George
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include <stdio.h>
+
+#include "py/obj.h"
+
+STATIC const char *help_text =
+"Welcome to the Micro Python RIOT port!\n"
+"\n"
+"Quick overview of commands for the board:\n"
+"(none so far)\n"
+"\n"
+"Control commands:\n"
+"  CTRL-A        -- on a blank line, enter raw REPL mode\n"
+"  CTRL-B        -- on a blank line, enter normal REPL mode\n"
+"  CTRL-C        -- interrupt a running program\n"
+"  CTRL-D        -- on a blank line, do a soft reset of the board\n"
+" (all probably not working in this initial port)"
+"\n"
+"For further help on a specific object, type help(obj)\n"
+;
+
+STATIC void pyb_help_print_info_about_object(mp_obj_t name_o, mp_obj_t value) {
+    printf("  ");
+    mp_obj_print(name_o, PRINT_STR);
+    printf(" -- ");
+    mp_obj_print(value, PRINT_STR);
+    printf("\n");
+}
+
+STATIC mp_obj_t pyb_help(uint n_args, const mp_obj_t *args) {
+    if (n_args == 0) {
+        // print a general help message
+        printf("%s", help_text);
+
+    } else {
+        // try to print something sensible about the given object
+
+        printf("object ");
+        mp_obj_print(args[0], PRINT_STR);
+        printf(" is of type %s\n", mp_obj_get_type_str(args[0]));
+
+        mp_map_t *map = NULL;
+        if (MP_OBJ_IS_TYPE(args[0], &mp_type_module)) {
+            map = mp_obj_dict_get_map(mp_obj_module_get_globals(args[0]));
+        } else {
+            mp_obj_type_t *type;
+            if (MP_OBJ_IS_TYPE(args[0], &mp_type_type)) {
+                type = args[0];
+            } else {
+                type = mp_obj_get_type(args[0]);
+            }
+            if (type->locals_dict != MP_OBJ_NULL && MP_OBJ_IS_TYPE(type->locals_dict, &mp_type_dict)) {
+                map = mp_obj_dict_get_map(type->locals_dict);
+            }
+        }
+        if (map != NULL) {
+            for (uint i = 0; i < map->alloc; i++) {
+                if (map->table[i].key != MP_OBJ_NULL) {
+                    pyb_help_print_info_about_object(map->table[i].key, map->table[i].value);
+                }
+            }
+        }
+    }
+
+    return mp_const_none;
+}
+
+MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin_help_obj, 0, 1, pyb_help);
diff --git a/riot/mp_riot.c b/riot/mp_riot.c
new file mode 100644
index 0000000..8e254e6
--- /dev/null
+++ b/riot/mp_riot.c
@@ -0,0 +1,75 @@
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "py/nlr.h"
+#include "py/compile.h"
+#include "py/runtime.h"
+#include "py/repl.h"
+#include "py/gc.h"
+#include "pyexec.h"
+
+#include "thread.h"
+
+void mp_do_str(const char *src, int len)
+{
+    mp_lexer_t *lex = mp_lexer_new_from_str_len(MP_QSTR__lt_stdin_gt_, src, len, 0);
+    if (lex == NULL) {
+        printf("MemoryError: lexer could not allocate memory\n");
+        return;
+    }
+
+    nlr_buf_t nlr;
+    if (nlr_push(&nlr) == 0) {
+        qstr source_name = lex->source_name;
+        mp_parse_node_t pn = mp_parse(lex, MP_PARSE_FILE_INPUT);
+        mp_obj_t module_fun = mp_compile(pn, source_name, MP_EMIT_OPT_NONE, true);
+        mp_call_function_0(module_fun);
+        nlr_pop();
+    } else {
+        // uncaught exception
+        mp_obj_print_exception(&mp_plat_print, (mp_obj_t)nlr.ret_val);
+    }
+}
+
+#if MICROPY_ENABLE_GC
+static char *_stack_start;
+static int _stack_size;
+#endif
+
+void mp_riot_init(char* stack_start, int stack_size, char* heap, int heap_size)
+{
+    #if MICROPY_ENABLE_GC
+    _stack_start = stack_start;
+    _stack_size = stack_size;
+
+    gc_init(heap, heap + heap_size);
+    #endif
+
+    mp_init();
+}
+
+void gc_collect(void) {
+    gc_collect_start();
+    /* TODO: fix register selection */
+    void *dummy;
+    gc_collect_root(&dummy, 0);
+    gc_collect_end();
+    gc_dump_info();
+}
+
+mp_lexer_t *mp_lexer_new_from_file(const char *filename) {
+    return NULL;
+}
+
+mp_import_stat_t mp_import_stat(const char *path) {
+    return MP_IMPORT_STAT_NO_EXIST;
+}
+
+mp_obj_t mp_builtin_open(uint n_args, const mp_obj_t *args, mp_map_t *kwargs) {
+    return mp_const_none;
+}
+MP_DEFINE_CONST_FUN_OBJ_KW(mp_builtin_open_obj, 1, mp_builtin_open);
+
+void nlr_jump_fail(void *val) {
+}
diff --git a/riot/mpconfigport.h b/riot/mpconfigport.h
new file mode 100644
index 0000000..2158199
--- /dev/null
+++ b/riot/mpconfigport.h
@@ -0,0 +1,95 @@
+#include <stdint.h>
+
+// options to control how Micro Python is built
+
+#define MICROPY_ALLOC_PATH_MAX      (256)
+#define MICROPY_EMIT_X64            (0)
+#define MICROPY_EMIT_THUMB          (0)
+#define MICROPY_EMIT_INLINE_THUMB   (0)
+#define MICROPY_COMP_MODULE_CONST   (0)
+#define MICROPY_COMP_CONST          (0)
+#define MICROPY_COMP_DOUBLE_TUPLE_ASSIGN (0)
+#define MICROPY_COMP_TRIPLE_TUPLE_ASSIGN (0)
+#define MICROPY_MEM_STATS           (0)
+#define MICROPY_DEBUG_PRINTERS      (0)
+#define MICROPY_ENABLE_GC           (1)
+#define MICROPY_REPL_EVENT_DRIVEN   (0)
+#define MICROPY_HELPER_REPL         (1)
+#define MICROPY_HELPER_LEXER_UNIX   (0)
+#define MICROPY_ENABLE_SOURCE_LINE  (0)
+#define MICROPY_ENABLE_DOC_STRING   (0)
+#define MICROPY_ERROR_REPORTING     (MICROPY_ERROR_REPORTING_TERSE)
+#define MICROPY_PY_BUILTINS_BYTEARRAY (0)
+#define MICROPY_PY_BUILTINS_MEMORYVIEW (0)
+#define MICROPY_PY_BUILTINS_ENUMERATE (0)
+#define MICROPY_PY_BUILTINS_FROZENSET (0)
+#define MICROPY_PY_BUILTINS_REVERSED (0)
+#define MICROPY_PY_BUILTINS_SET     (0)
+#define MICROPY_PY_BUILTINS_SLICE   (0)
+#define MICROPY_PY_BUILTINS_PROPERTY (0)
+#define MICROPY_PY___FILE__         (0)
+#define MICROPY_PY_GC               (0)
+#define MICROPY_PY_ARRAY            (0)
+#define MICROPY_PY_ATTRTUPLE        (0)
+#define MICROPY_PY_COLLECTIONS      (0)
+#define MICROPY_PY_MATH             (0)
+#define MICROPY_PY_MICROPYTHON_MEM_INFO (1)
+#define MICROPY_PY_CMATH            (0)
+#define MICROPY_PY_IO               (0)
+#define MICROPY_PY_STRUCT           (0)
+#define MICROPY_PY_SYS              (0)
+#define MICROPY_MODULE_FROZEN       (0)
+#define MICROPY_CPYTHON_COMPAT      (0)
+#define MICROPY_LONGINT_IMPL        (MICROPY_LONGINT_IMPL_NONE)
+#define MICROPY_FLOAT_IMPL          (MICROPY_FLOAT_IMPL_NONE)
+
+// type definitions for the specific machine
+
+#define BYTES_PER_WORD (4)
+
+#define MICROPY_MAKE_POINTER_CALLABLE(p) ((void*)((mp_uint_t)(p) | 1))
+
+// This port is intended to be 32-bit, but unfortunately, int32_t for
+// different targets may be defined in different ways - either as int
+// or as long. This requires different printf formatting specifiers
+// to print such value. So, we avoid int32_t and use int directly.
+#define UINT_FMT "%u"
+#define INT_FMT "%d"
+typedef int mp_int_t; // must be pointer size
+typedef unsigned mp_uint_t; // must be pointer size
+
+typedef void *machine_ptr_t; // must be of pointer size
+typedef const void *machine_const_ptr_t; // must be of pointer size
+typedef long mp_off_t;
+
+void mp_hal_stdout_tx_strn_cooked(const char *str, mp_uint_t len);
+#define MP_PLAT_PRINT_STRN(str, len) mp_hal_stdout_tx_strn_cooked(str, len)
+
+// extra built in names to add to the global namespace
+extern const struct _mp_obj_fun_builtin_t mp_builtin_open_obj;
+extern const struct _mp_obj_fun_builtin_t mp_builtin_help_obj;
+#define MICROPY_PORT_BUILTINS \
+    { MP_OBJ_NEW_QSTR(MP_QSTR_help), (mp_obj_t)&mp_builtin_help_obj }, \
+    { MP_OBJ_NEW_QSTR(MP_QSTR_open), (mp_obj_t)&mp_builtin_open_obj },
+
+// We need to provide a declaration/definition of alloca()
+#include <alloca.h>
+
+#define HAL_GetTick() 0
+int mp_hal_stdin_rx_chr(void);
+void mp_hal_stdout_tx_str(const char *str);
+void mp_hal_stdout_tx_strn(const char *str, mp_uint_t len);
+void mp_hal_stdout_tx_strn_cooked(const char *str, mp_uint_t len);
+
+static inline void mp_hal_set_interrupt_char(char c) {(void)c;}
+
+#define str(x) #x
+#define xstr(x) str(x)
+#define MICROPY_HW_BOARD_NAME xstr(RIOT_BOARD)
+#define MICROPY_HW_MCU_NAME xstr(RIOT_MCU)
+
+#define MP_STATE_PORT MP_STATE_VM
+
+#define MICROPY_PORT_ROOT_POINTERS \
+    const char *readline_hist[8];
+
diff --git a/riot/qstrdefsport.h b/riot/qstrdefsport.h
new file mode 100644
index 0000000..0578307
--- /dev/null
+++ b/riot/qstrdefsport.h
@@ -0,0 +1,3 @@
+// qstrs specific to this port
+
+Q(help)
diff --git a/riot/riot_io.c b/riot/riot_io.c
new file mode 100644
index 0000000..c54eff0
--- /dev/null
+++ b/riot/riot_io.c
@@ -0,0 +1,46 @@
+#include <unistd.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "py/mpconfig.h"
+
+/*
+ * Core UART functions to implement for a port
+ */
+
+// Receive single character
+int mp_hal_stdin_rx_chr(void) {
+    unsigned char c = 0;
+    int r = read(STDIN_FILENO, &c, 1);
+    if (r) {
+        if (c == '\n') {
+            c = '\r';
+        }
+    }
+    return c;
+}
+
+// Send string of given length
+void mp_hal_stdout_tx_strn(const char *str, mp_uint_t len) {
+    int r = write(STDOUT_FILENO, str, len);
+    (void)r;
+}
+/*
+ * Extra IO functions
+ */
+
+// Send "cooked" string of length, where every occurance of
+// LF character is replaced with CR LF.
+void mp_hal_stdout_tx_strn_cooked(const char *str, mp_uint_t len) {
+    while (len--) {
+        if (*str == '\n') {
+            mp_hal_stdout_tx_strn("\r", 1);
+        }
+        mp_hal_stdout_tx_strn(str++, 1);
+    }
+}
+
+// Send zero-terminated string
+void mp_hal_stdout_tx_str(const char *str) {
+    mp_hal_stdout_tx_strn(str, strlen(str));
+}
-- 
2.9.0

