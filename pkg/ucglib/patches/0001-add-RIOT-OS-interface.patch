From 86492024e0487d9d9c52f42d99a3406a3261a557 Mon Sep 17 00:00:00 2001
From: Bas Stottelaar <basstottelaar@gmail.com>
Date: Fri, 2 Mar 2018 00:16:43 +0100
Subject: [PATCH 1/1] add RIOT-OS interface.

---
 csrc/ucg.h        |  29 +++++++----
 csrc/ucg_riotos.c | 152 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 171 insertions(+), 10 deletions(-)
 create mode 100644 csrc/ucg_riotos.c

diff --git a/csrc/ucg.h b/csrc/ucg.h
index c070a77..553562c 100644
--- a/csrc/ucg.h
+++ b/csrc/ucg.h
@@ -84,17 +84,19 @@
 #include <stdint.h>
 #include <stddef.h>
 
+#include "periph/gpio.h"
+
 
 #ifdef __cplusplus
 extern "C"
 {
 #endif
 
-#if defined(ARDUINO)
-#ifndef USE_PIN_LIST
+//#if defined(ARDUINO)
+//#ifndef USE_PIN_LIST
 #define USE_PIN_LIST
-#endif
-#endif
+//#endif
+//#endif
 
 #ifdef __GNUC__
 #  define UCG_NOINLINE __attribute__((noinline))
@@ -413,12 +415,14 @@ struct _ucg_t
 
   /* only for Arduino/C++ Interface */
 #ifdef USE_PIN_LIST
-  uint8_t pin_list[UCG_PIN_COUNT];
+  gpio_t* pin_list;
+  uint32_t pins_enabled;
+  uint32_t dev;
 
-#ifdef __AVR__
-  volatile uint8_t *data_port[UCG_PIN_COUNT];
-  uint8_t data_mask[UCG_PIN_COUNT];
-#endif
+//#ifdef __AVR__
+//  volatile uint8_t *data_port[UCG_PIN_COUNT];
+//  uint8_t data_mask[UCG_PIN_COUNT];
+//#endif
 
 #endif
 
@@ -434,6 +438,9 @@ struct _ucg_t
   
 };
 
+#define ucg_SetPins(ucg,pins,pins_enabled) {(ucg)->pin_list = (pins); (ucg)->pins_enabled = (pins_enabled);}
+#define ucg_SetDevice(ucg,device) ((ucg)->dev = device)
+
 #define ucg_GetWidth(ucg) ((ucg)->dimension.w)
 #define ucg_GetHeight(ucg) ((ucg)->dimension.h)
 
@@ -574,6 +581,7 @@ ucg_int_t ucg_Init(ucg_t *ucg, ucg_dev_fnptr device_cb, ucg_dev_fnptr ext_cb, uc
 /*================================================*/
 /* ucg_dev_sdl.c */
 ucg_int_t ucg_sdl_dev_cb(ucg_t *ucg, ucg_int_t msg, void *data);
+int ucg_sdl_get_key(void);
 
 /*================================================*/
 /* ucg_pixel.c */
@@ -2172,7 +2180,8 @@ extern const ucg_fntpgm_uint8_t ucg_font_osr41_tr[] UCG_FONT_SECTION("ucg_font_o
 
 #endif
 
-
+int16_t ucg_com_riotos_hw_spi(ucg_t *ucg, int16_t msg, uint16_t arg, uint8_t *data);
+ucg_int_t ucg_dev_dummy_cb(ucg_t *ucg, ucg_int_t msg, void *data);
 
 #ifdef __cplusplus
 }
diff --git a/csrc/ucg_riotos.c b/csrc/ucg_riotos.c
new file mode 100644
index 0000000..b3bcccc
--- /dev/null
+++ b/csrc/ucg_riotos.c
@@ -0,0 +1,152 @@
+#include "ucg.h"
+
+#include "xtimer.h"
+
+#include "periph/spi.h"
+#include "periph/i2c.h"
+#include "periph/gpio.h"
+
+#include <stdio.h>
+
+#ifdef SPI_NUMOF
+static spi_clk_t ucg_serial_clk_speed_to_spi_speed(uint32_t serial_clk_speed)
+{
+    if (serial_clk_speed < 100) {
+        return SPI_CLK_10MHZ;
+    }
+    else if (serial_clk_speed < 200) {
+        return SPI_CLK_5MHZ;
+    }
+    else if (serial_clk_speed < 1000) {
+        return SPI_CLK_1MHZ;
+    }
+    else if (serial_clk_speed < 2500) {
+        return SPI_CLK_400KHZ;
+    }
+
+    return SPI_CLK_100KHZ;
+}
+#endif /* SPI_NUMOF */
+
+static void ucg_enable_pins(gpio_t *pins, uint32_t pins_enabled)
+{
+    uint8_t i;
+
+    for (i = 0; i < 32; i++) {
+        if (pins_enabled & (1 << i)) {
+            if (pins[i] != GPIO_UNDEF) {
+                if (i < UCG_PIN_COUNT) {
+                    gpio_init(pins[i], GPIO_OUT);
+                }
+                else {
+                    gpio_init(pins[i], GPIO_IN);
+                }
+            }
+        }
+    }
+}
+
+#ifdef SPI_NUMOF
+int16_t ucg_com_riotos_hw_spi(ucg_t *ucg, int16_t msg, uint16_t arg, uint8_t *data)
+{
+    spi_t dev = (spi_t) ucg->dev;
+
+    switch (msg) {
+        case UCG_COM_MSG_POWER_UP:
+            /* setup pins */
+            ucg_enable_pins(ucg->pin_list, ucg->pins_enabled);
+
+            /* setup Arduino SPI */
+            spi_init_pins(dev);
+            spi_acquire(dev, GPIO_UNDEF, SPI_MODE_0,
+                        ucg_serial_clk_speed_to_spi_speed(((ucg_com_info_t *)data)->serial_clk_speed));
+
+            break;
+        case UCG_COM_MSG_POWER_DOWN:
+            spi_release(dev);
+            break;
+        case UCG_COM_MSG_DELAY:
+            xtimer_usleep(arg);
+            break;
+        case UCG_COM_MSG_CHANGE_RESET_LINE:
+            if (ucg->pins_enabled & (1 << UCG_PIN_RST)) {
+                gpio_write(ucg->pin_list[UCG_PIN_RST], arg);
+            }
+            break;
+        case UCG_COM_MSG_CHANGE_CS_LINE:
+            if (ucg->pins_enabled & (1 << UCG_PIN_CS)) {
+                gpio_write(ucg->pin_list[UCG_PIN_CS], arg);
+            }
+            break;
+        case UCG_COM_MSG_CHANGE_CD_LINE:
+            if (ucg->pins_enabled & (1 << UCG_PIN_CD)) {
+                gpio_write(ucg->pin_list[UCG_PIN_CD], arg);
+            }
+            break;
+        case UCG_COM_MSG_SEND_BYTE:
+            spi_transfer_byte(dev, GPIO_UNDEF, true, (uint8_t) arg);
+            break;
+        case UCG_COM_MSG_REPEAT_1_BYTE:
+            while (arg--) {
+                spi_transfer_byte(dev, GPIO_UNDEF, true, ((uint8_t *) data)[0]);
+            }
+            break;
+        case UCG_COM_MSG_REPEAT_2_BYTES:
+            while (arg--) {
+                spi_transfer_bytes(dev, GPIO_UNDEF, true, data, NULL, 2);
+            }
+            break;
+        case UCG_COM_MSG_REPEAT_3_BYTES:
+            while (arg--) {
+                spi_transfer_bytes(dev, GPIO_UNDEF, true, data, NULL, 3);
+            }
+            break;
+        case UCG_COM_MSG_SEND_STR:
+            spi_transfer_bytes(dev, GPIO_UNDEF, true, data, NULL, arg);
+            break;
+        case UCG_COM_MSG_SEND_CD_DATA_SEQUENCE:
+            while (arg--) {
+                if (*data != 0) {
+                    if (ucg->pins_enabled & (1 << UCG_PIN_CD)) {
+                        gpio_write(ucg->pin_list[UCG_PIN_CD], *data);
+                    }
+                }
+
+                data++;
+                spi_transfer_bytes(dev, GPIO_UNDEF, true, data, NULL, 1);
+                data++;
+            }
+            break;
+    }
+
+    return 1;
+}
+#endif /* SPI_NUMOF */
+
+ucg_int_t ucg_dev_dummy_cb(ucg_t *ucg, ucg_int_t msg, void *data)
+{
+    static uint32_t pixels;
+
+    switch(msg) {
+        case UCG_MSG_DEV_POWER_UP:
+            puts("ucg: UCG_MSG_DEV_POWER_UP");
+            return 1;
+        case UCG_MSG_DEV_POWER_DOWN:
+            puts("ucg: UCG_MSG_DEV_POWER_DOWN");
+            return 1;
+        case UCG_MSG_GET_DIMENSION:
+            puts("ucg: UCG_MSG_GET_DIMENSION");
+            ((ucg_wh_t *)data)->w = 128;
+            ((ucg_wh_t *)data)->h = 128;
+            return 1;
+        case UCG_MSG_DRAW_PIXEL:
+            pixels++;
+
+            if (pixels % 128 == 0) {
+                printf("ucg: UCG_MSG_DRAW_PIXEL (%d)\n", pixels);
+            }
+
+            return 1;
+    }
+    return ucg_dev_default_cb(ucg, msg, data);
+}
-- 
2.14.2

