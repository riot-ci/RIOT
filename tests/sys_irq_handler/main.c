/*
 * Copyright (C) 2019 Gunar Schorcht
 *
 * This file is subject to the terms and conditions of the GNU Lesser
 * General Public License v2.1. See the file LICENSE in the top level
 * directory for more details.
 */

/**
 * @ingroup tests
 * @{
 *
 * @file
 * @brief       Interrupt handler test application
 *
 * @author      Gunar Schorcht <gunar@schorcht.net>
 *
 * This application demonstrates how to use the interrupt handler thread
 * module `irq_handler`. For that purpose the main thread simulates interrupts
 * from 2 interrupt sources with different priorities with a period
 * of a half second. One interrupt source triggeres a second interrupt before
 * the interrupts can be handled by the interrupt handler.
 *
 * To be able to simulate the interrupts by the main thread, the interrupt
 * handler thread has to have a lower priority as the main thread for this
 * example. Otherwise, the interrupts would be handled immediatly when they
 * are generated by the main thread. Therefore the interrupt handler thread
 * priority is set to THREAD_PRIORITY_MAIN+1 for this example.
 * @}
 */

#include <stdio.h>

#include "irq_handler.h"
#include "thread.h"
#include "xtimer.h"

static char some_stack[THREAD_STACKSIZE_MAIN];
static volatile int i = 0;
static volatile int k = 10;

/* preallocated and initialized interrupt event objects */
static irq_event_t _int1_event = IRQ_EVENT_INIT;
static irq_event_t _int2_event = IRQ_EVENT_INIT;

/* interrupt service routine for a simulated interrupt from source 1 */
void _int1_service (void *arg)
{
    (void)arg;
    puts("int1 triggered");
    /* registers just the interrupt event and returns */
    if (irq_event_add(&_int1_event) == -1) {
        puts("int1 is already pending");
    }
}

/* interrupt handler for interrupts from source 1 */
void _int1_handler(void *ctx)
{
    (void)ctx;
    puts("int1 handled");
}

/* interrupt service routine for a simulated interrupt from source 2 */
void _int2_service (void *arg)
{
    (void)arg;
    puts("int2 triggered");
    /* registers just the interrupt event and returns */
    if (irq_event_add(&_int2_event) == -1) {
        puts("int2 is already pending");
    }
}

/* interrupt handler for interrupts from source 2 */
void _int2_handler(void *ctx)
{
    (void)ctx;
    puts("int2 handled");
}

void *some_thread(void *arg)
{
    (void)arg;

    puts("some_thread is starting");

    while (1) {
        i++;
        xtimer_usleep(US_PER_MS);
    }
    return NULL;
}

int main(void)
{
    _int1_event.isr = _int1_handler;
    _int1_event.ctx = (void*)sched_active_thread;

    _int2_event.isr = _int2_handler;
    _int2_event.ctx = (void*)sched_active_thread;

    puts("START");

    thread_create(some_stack, sizeof(some_stack),
                  THREAD_PRIORITY_MAIN + 2, THREAD_CREATE_WOUT_YIELD,
                  some_thread, NULL, "some_thread");
    puts("some_thread created");

    /* wait to let some_thread to start */
    xtimer_usleep(US_PER_SEC);

    i = 0;

    while (k--) {
        /*
         * Simulate two interrupt sources where one interrupt source generates
         * two interrupts.
         */
        _int1_service(0);
        _int2_service(0);
        _int1_service(0);

        /*
         * Suspend the main thread, interrupts should be handled. After handling
         * the interrupts, some thread should be executed and should increment
         * i.
         */
        xtimer_usleep(500 * US_PER_MS);
    }
    if (i > 0) {
        puts("[SUCCESS]");
    }

    return 0;
}
